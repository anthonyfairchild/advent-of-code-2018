* Advent of Code 2018
** Day 2
*** Part 1
#+BEGIN_SRC clojure :results pp
  (defn twos-and-threes
    [str]
    (let [counts (->> str
                      (group-by identity)
                      (map (fn [[_ cs]] (count cs)))
                      set)]
      [(if (> (get counts 2 0) 0) 1 0)
       (if (> (get counts 3 0) 0) 1 0)]))

  (->> "input/day02.txt"
       slurp
       clojure.string/split-lines
       (map twos-and-threes)
       (reduce (fn [[twos threes] [tws ths]]
                 [(+ twos tws) (+ threes ths)])
               [0 0])
       (apply *))
#+END_SRC

#+RESULTS:
: 5928

*** Part 2
#+BEGIN_SRC clojure :results pp
  (defn diff-strs
    [str1 str2]
    (->> (map vector str1 str2)
         (reduce (fn [diffs [a b]]
                   (+ diffs (if (= a b) 0 1)))
                 0)))

  (defn unique-pairs
    [cs]
    (->> cs
         (map-indexed vector)
         (mapcat (fn [[i c]]
                   (for [x (drop (inc i) cs)]
                     [c x])))))

  (->> "input/day02.txt"
       slurp
       clojure.string/split-lines
       unique-pairs
       (filter (fn [[a b]] (= (diff-strs a b) 1)))
       first
       (apply map vector)
       (filter (fn [[a b]] (= a b)))
       (map first)
       (apply str))
#+END_SRC

#+RESULTS:
: "bqlporuexkwzyabnmgjqctvfs"

** Day 1
*** Part 1
#+BEGIN_SRC clojure :results pp
  (->> "input/day01.txt"
       slurp
       clojure.string/split-lines
       (map #(Integer/parseInt %))
       (reduce +))
#+END_SRC

#+RESULTS:
: 484

*** Part 2
#+BEGIN_SRC clojure :results pp
  (->> "input/day01.txt"
       slurp
       clojure.string/split-lines
       (map #(Integer/parseInt %))
       repeat
       flatten
       (reduce (fn [[freqs sum] n]
                 (let [sum (+ sum n)]
                   (if (get freqs sum)
                     (reduced sum)
                     [(conj freqs sum) sum])))
               [#{} 0]))
#+END_SRC

#+RESULTS:
: 367
