* Advent of Code 2018
** Day 3
*** Part 1
#+BEGIN_SRC clojure :results pp
  (defn parse-input
    [line]
    (->> line
         (map #(re-find #"^#(\d+) @ (\d+),(\d+): (\d+)x(\d+)$" %))
         (map #(drop 1 %))
         (map (fn [cs] (map #(Integer/parseInt %) cs)))
         (map vec)))

  (defn plot-claim
    [m [id left top width height]]
    (reduce (fn [m [x y]]
              (let [x (+ left x)
                    y (+ top y)]
                (assoc m [x y] (inc (get m [x y] 0)))))
            m
            (for [x (range width)
                  y (range height)]
              [x y])))

  (->> "input/day03.txt"
       slurp
       clojure.string/split-lines
       parse-input
       (reduce plot-claim {})
       (map second)
       (filter #(> % 1))
       count)
#+END_SRC

#+RESULTS:
: 100595

*** Part 2
#+BEGIN_SRC clojure :results pp
  (defn parse-input
    [line]
    (->> line
         (map #(re-find #"^#(\d+) @ (\d+),(\d+): (\d+)x(\d+)$" %))
         (map #(drop 1 %))
         (map (fn [cs] (map #(Integer/parseInt %) cs)))
         (map vec)))

  (defn plot-claim
    [m [id left top width height]]
    (reduce (fn [m [x y]]
              (let [x (+ left x)
                    y (+ top y)]
                (assoc m [x y] (conj (get m [x y] [])
                                     id))))
            m
            (for [x (range width)
                  y (range height)]
              [x y])))

  (def input (->> "input/day03.txt"
                  slurp
                  clojure.string/split-lines
                  parse-input))

  (def all-claim-ids (->> input
                          (map first)
                          set))

  (defn remove-overlapping-claim
    [claims cell]
    (if (= 1 (count cell))
      claims
      (clojure.set/difference claims cell)))

  (->> input
       (reduce plot-claim {})
       (map second)
       (map set)
       (reduce remove-overlapping-claim
               all-claim-ids)
       first)
#+END_SRC

#+RESULTS:
: 415

** Day 2
*** Part 1
#+BEGIN_SRC clojure :results pp
  (defn twos-and-threes
    [str]
    (let [counts (->> str
                      (group-by identity)
                      (map (fn [[_ cs]] (count cs)))
                      set)]
      [(if (> (get counts 2 0) 0) 1 0)
       (if (> (get counts 3 0) 0) 1 0)]))

  (->> "input/day02.txt"
       slurp
       clojure.string/split-lines
       (map twos-and-threes)
       (reduce (fn [[twos threes] [tws ths]]
                 [(+ twos tws) (+ threes ths)])
               [0 0])
       (apply *))
#+END_SRC

#+RESULTS:
: 5928

*** Part 2
#+BEGIN_SRC clojure :results pp
  (defn diff-strs
    [str1 str2]
    (->> (map vector str1 str2)
         (reduce (fn [diffs [a b]]
                   (+ diffs (if (= a b) 0 1)))
                 0)))

  (defn unique-pairs
    [cs]
    (->> cs
         (map-indexed vector)
         (mapcat (fn [[i c]]
                   (for [x (drop (inc i) cs)]
                     [c x])))))

  (->> "input/day02.txt"
       slurp
       clojure.string/split-lines
       unique-pairs
       (filter (fn [[a b]] (= (diff-strs a b) 1)))
       first
       (apply map vector)
       (filter (fn [[a b]] (= a b)))
       (map first)
       (apply str))
#+END_SRC

#+RESULTS:
: "bqlporuexkwzyabnmgjqctvfs"

** Day 1
*** Part 1
#+BEGIN_SRC clojure :results pp
  (->> "input/day01.txt"
       slurp
       clojure.string/split-lines
       (map #(Integer/parseInt %))
       (reduce +))
#+END_SRC

#+RESULTS:
: 484

*** Part 2
#+BEGIN_SRC clojure :results pp
  (->> "input/day01.txt"
       slurp
       clojure.string/split-lines
       (map #(Integer/parseInt %))
       repeat
       flatten
       (reduce (fn [[freqs sum] n]
                 (let [sum (+ sum n)]
                   (if (get freqs sum)
                     (reduced sum)
                     [(conj freqs sum) sum])))
               [#{} 0]))
#+END_SRC

#+RESULTS:
: 367
